"""
This file was generated by Claude AI
"""
import api
import sys
import traceback

# Try to import tkinter and handle if missing
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, scrolledtext
    TKINTER_AVAILABLE = True
except ImportError as e:
    api.log(f"Tkinter not available: {e}", api.ERROR)
    TKINTER_AVAILABLE = False

import json
import urllib.request
import urllib.error
import os
import threading
import platform
from pathlib import Path

CATALOG_URL = "https://raw.githubusercontent.com/hydrophobis/DLLPluginSystem/refs/heads/main/catalog.json"
PLUGIN_DIR = "plugins"

class PluginManagerGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Plugin Manager - DLLPluginSystem")
        self.root.geometry("900x650")
        self.root.minsize(800, 600)
        
        # Ensure window appears on top initially
        self.root.lift()
        self.root.attributes('-topmost', True)
        self.root.after_idle(self.root.attributes, '-topmost', False)
        
        # Data
        self.catalog = {"plugins": []}
        self.installed_plugins = set()
        self.loaded_plugins = set()
        self.filter_type = "all"
        self.search_term = ""
        
        # Styling
        self.setup_styles()
        self.create_ui()
        
        # Load initial data
        self.refresh_catalog()
        self.scan_installed_plugins()
        
        # Handle window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        api.log("Plugin Manager GUI initialized", api.INFO)
    
    def setup_styles(self):
        """Configure modern styling"""
        style = ttk.Style()
        
        # Use a theme that works on Windows
        available_themes = style.theme_names()
        if 'vista' in available_themes:
            style.theme_use('vista')
        elif 'clam' in available_themes:
            style.theme_use('clam')
        
        # Colors
        bg_dark = "#1e1e1e"
        bg_medium = "#2d2d2d"
        bg_light = "#3e3e3e"
        accent = "#007acc"
        text_color = "#cccccc"
        
        # Configure styles
        style.configure("TFrame", background=bg_dark)
        style.configure("TLabel", background=bg_dark, foreground=text_color, font=("Segoe UI", 10))
        style.configure("Title.TLabel", font=("Segoe UI", 16, "bold"), foreground=accent)
        style.configure("Subtitle.TLabel", font=("Segoe UI", 9), foreground="#888888")
        style.configure("TButton", background=bg_medium, foreground=text_color, 
                       borderwidth=1, relief="flat", font=("Segoe UI", 9))
        style.map("TButton", background=[("active", bg_light)])
        
        style.configure("Accent.TButton", background=accent, foreground="white")
        style.map("Accent.TButton", background=[("active", "#005a9e")])
        
        self.root.configure(bg=bg_dark)
    
    def create_ui(self):
        """Build the main interface"""
        # Header
        header = ttk.Frame(self.root, padding="20")
        header.pack(fill="x")
        
        ttk.Label(header, text="üîå Plugin Manager", style="Title.TLabel").pack(anchor="w")
        ttk.Label(header, text="Manage your DLLPluginSystem plugins", 
                 style="Subtitle.TLabel").pack(anchor="w")
        
        # Toolbar
        toolbar = ttk.Frame(self.root, padding="10 5")
        toolbar.pack(fill="x")
        
        # Search
        search_frame = ttk.Frame(toolbar)
        search_frame.pack(side="left", fill="x", expand=True, padx=(0, 10))
        
        ttk.Label(search_frame, text="üîç").pack(side="left", padx=(0, 5))
        self.search_var = tk.StringVar()
        self.search_var.trace("w", lambda *args: self.apply_filters())
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=30)
        search_entry.pack(side="left", fill="x", expand=True)
        
        # Filter dropdown
        ttk.Label(toolbar, text="Filter:").pack(side="left", padx=(0, 5))
        self.filter_var = tk.StringVar(value="all")
        filter_combo = ttk.Combobox(toolbar, textvariable=self.filter_var, 
                                    values=["all", "DLL", "Python", "SO", "installed", "not installed"],
                                    state="readonly", width=15)
        filter_combo.pack(side="left", padx=(0, 10))
        filter_combo.bind("<<ComboboxSelected>>", lambda e: self.apply_filters())
        
        # Refresh button
        ttk.Button(toolbar, text="üîÑ Refresh", command=self.refresh_catalog).pack(side="left", padx=2)
        
        # Main content area with paned window
        paned = ttk.PanedWindow(self.root, orient="horizontal")
        paned.pack(fill="both", expand=True, padx=10, pady=(0, 10))
        
        # Left panel - Plugin list
        left_panel = ttk.Frame(paned)
        paned.add(left_panel, weight=1)
        
        # Plugin list with scrollbar
        list_frame = ttk.Frame(left_panel)
        list_frame.pack(fill="both", expand=True)
        
        scrollbar = ttk.Scrollbar(list_frame)
        scrollbar.pack(side="right", fill="y")
        
        self.plugin_listbox = tk.Listbox(list_frame, yscrollcommand=scrollbar.set,
                                         bg="#2d2d2d", fg="#cccccc", 
                                         selectbackground="#007acc",
                                         selectforeground="white",
                                         font=("Segoe UI", 10),
                                         borderwidth=0, highlightthickness=0)
        self.plugin_listbox.pack(side="left", fill="both", expand=True)
        scrollbar.config(command=self.plugin_listbox.yview)
        
        self.plugin_listbox.bind("<<ListboxSelect>>", self.on_plugin_select)
        
        # Right panel - Plugin details
        right_panel = ttk.Frame(paned, padding="10")
        paned.add(right_panel, weight=1)
        
        # Details area
        details_scroll = scrolledtext.ScrolledText(right_panel, wrap="word", 
                                                   bg="#2d2d2d", fg="#cccccc",
                                                   font=("Segoe UI", 10),
                                                   borderwidth=0, highlightthickness=0,
                                                   state="disabled")
        details_scroll.pack(fill="both", expand=True, pady=(0, 10))
        self.details_text = details_scroll
        
        # Action buttons
        action_frame = ttk.Frame(right_panel)
        action_frame.pack(fill="x")
        
        self.install_btn = ttk.Button(action_frame, text="üì• Install", 
                                      style="Accent.TButton",
                                      command=self.install_selected)
        self.install_btn.pack(side="left", fill="x", expand=True, padx=(0, 5))
        
        self.uninstall_btn = ttk.Button(action_frame, text="üóëÔ∏è Uninstall",
                                        command=self.uninstall_selected)
        self.uninstall_btn.pack(side="left", fill="x", expand=True, padx=(0, 5))
        
        self.load_btn = ttk.Button(action_frame, text="‚ñ∂Ô∏è Load",
                                   command=self.load_selected)
        self.load_btn.pack(side="left", fill="x", expand=True)
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(self.root, textvariable=self.status_var, 
                              relief="sunken", anchor="w")
        status_bar.pack(fill="x", side="bottom")
    
    def refresh_catalog(self):
        """Fetch the latest catalog from GitHub"""
        self.status_var.set("Fetching catalog...")
        
        def fetch():
            try:
                with urllib.request.urlopen(CATALOG_URL, timeout=10) as response:
                    data = response.read().decode('utf-8')
                    self.catalog = json.loads(data)
                    self.root.after(0, self.populate_list)
                    self.root.after(0, lambda: self.status_var.set(
                        f"Catalog updated - {len(self.catalog['plugins'])} plugins available"))
                    api.log("Catalog refreshed successfully", api.INFO)
            except Exception as e:
                error_msg = str(e)
                self.root.after(0, lambda: messagebox.showerror(
                    "Error", f"Failed to fetch catalog:\n{error_msg}"))
                self.root.after(0, lambda: self.status_var.set("Failed to fetch catalog"))
                api.log(f"Failed to fetch catalog: {e}", api.ERROR)
        
        threading.Thread(target=fetch, daemon=True).start()
    
    def scan_installed_plugins(self):
        """Check which plugins are installed locally"""
        self.installed_plugins.clear()
        
        if not os.path.exists(PLUGIN_DIR):
            return
        
        try:
            for file in os.listdir(PLUGIN_DIR):
                if file.endswith(('.dll', '.so', '.py')):
                    # Extract base name without extension
                    base_name = os.path.splitext(file)[0]
                    self.installed_plugins.add(base_name)
            
            api.log(f"Found {len(self.installed_plugins)} installed plugins", api.INFO)
        except Exception as e:
            api.log(f"Error scanning plugins: {e}", api.ERROR)
    
    def apply_filters(self):
        """Apply search and filter to plugin list"""
        self.search_term = self.search_var.get().lower()
        self.filter_type = self.filter_var.get()
        self.populate_list()
    
    def populate_list(self):
        """Populate the plugin list with filtered results"""
        self.plugin_listbox.delete(0, tk.END)
        
        for plugin in self.catalog.get("plugins", []):
            # Apply filters
            if self.search_term:
                if (self.search_term not in plugin["name"].lower() and 
                    self.search_term not in plugin.get("description", "").lower()):
                    continue
            
            if self.filter_type != "all":
                is_installed = self.is_plugin_installed(plugin)
                
                if self.filter_type == "installed" and not is_installed:
                    continue
                elif self.filter_type == "not installed" and is_installed:
                    continue
                elif self.filter_type in ["DLL", "Python", "SO"] and plugin.get("type") != self.filter_type:
                    continue
            
            # Format display text
            status = "‚úì" if self.is_plugin_installed(plugin) else "‚óã"
            type_icon = {"DLL": "ü™ü", "Python": "üêç", "SO": "üêß"}.get(plugin.get("type"), "üì¶")
            
            display = f"{status} {type_icon} {plugin['name']}"
            self.plugin_listbox.insert(tk.END, display)
    
    def is_plugin_installed(self, plugin):
        """Check if a plugin is installed"""
        plugin_id = plugin.get("id", "")
        return plugin_id in self.installed_plugins
    
    def get_selected_plugin(self):
        """Get the currently selected plugin data"""
        selection = self.plugin_listbox.curselection()
        if not selection:
            return None
        
        # Get the actual index in filtered results
        selected_text = self.plugin_listbox.get(selection[0])
        
        # Find matching plugin
        for plugin in self.catalog.get("plugins", []):
            if plugin["name"] in selected_text:
                return plugin
        return None
    
    def on_plugin_select(self, event):
        """Handle plugin selection"""
        plugin = self.get_selected_plugin()
        if not plugin:
            return
        
        self.show_plugin_details(plugin)
        self.update_action_buttons(plugin)
    
    def show_plugin_details(self, plugin):
        """Display detailed plugin information"""
        self.details_text.config(state="normal")
        self.details_text.delete(1.0, tk.END)
        
        # Title
        self.details_text.insert(tk.END, f"{plugin['name']}\n", "title")
        self.details_text.tag_config("title", font=("Segoe UI", 14, "bold"), foreground="#007acc")
        
        # Metadata
        meta = f"\nüì¶ Type: {plugin.get('type', 'Unknown')}\n"
        meta += f"üë§ Author: {plugin.get('author', 'Unknown')}\n"
        meta += f"üìÅ Category: {plugin.get('category', 'General')}\n"
        
        if self.is_plugin_installed(plugin):
            meta += f"‚úì Status: Installed\n"
        else:
            meta += f"‚óã Status: Not installed\n"
        
        self.details_text.insert(tk.END, meta, "meta")
        self.details_text.tag_config("meta", foreground="#888888")
        
        # Description
        self.details_text.insert(tk.END, f"\nüìù Description:\n", "header")
        self.details_text.insert(tk.END, f"{plugin.get('description', 'No description available.')}\n")
        self.details_text.tag_config("header", font=("Segoe UI", 11, "bold"))
        
        # Dependencies
        deps = plugin.get("dependencies", [])
        if deps:
            self.details_text.insert(tk.END, f"\nüîó Dependencies:\n", "header")
            for dep in deps:
                req = "Required" if dep.get("required", False) else "Optional"
                dep_name = dep.get("id", "unknown")
                self.details_text.insert(tk.END, f"  ‚Ä¢ {dep_name} ({req})\n", "dep")
            self.details_text.tag_config("dep", foreground="#ffcc00")
        
        # Releases
        releases = plugin.get("releases", [])
        if releases:
            self.details_text.insert(tk.END, f"\nüì¶ Available Versions:\n", "header")
            for rel in releases:
                self.details_text.insert(tk.END, f"  ‚Ä¢ {rel.get('version', 'Unknown')}\n")
        
        self.details_text.config(state="disabled")
    
    def update_action_buttons(self, plugin):
        """Enable/disable action buttons based on plugin state"""
        is_installed = self.is_plugin_installed(plugin)
        
        if is_installed:
            self.install_btn.config(state="disabled", text="‚úì Installed")
            self.uninstall_btn.config(state="normal")
            self.load_btn.config(state="normal")
        else:
            self.install_btn.config(state="normal", text="üì• Install")
            self.uninstall_btn.config(state="disabled")
            self.load_btn.config(state="disabled")
    
    def install_selected(self):
        """Install the selected plugin"""
        plugin = self.get_selected_plugin()
        if not plugin:
            return
        
        # Check dependencies
        deps = plugin.get("dependencies", [])
        missing_deps = []
        
        for dep in deps:
            if dep.get("required", False) and dep.get("id") not in self.installed_plugins:
                missing_deps.append(dep.get("id"))
        
        if missing_deps:
            msg = f"Missing required dependencies:\n\n" + "\n".join(f"‚Ä¢ {d}" for d in missing_deps)
            msg += f"\n\nInstall dependencies first?"
            
            if not messagebox.askyesno("Dependencies Required", msg):
                return
        
        self.status_var.set(f"Installing {plugin['name']}...")
        
        def download():
            try:
                releases = plugin.get("releases", [])
                if not releases:
                    raise Exception("No releases available")
                
                url = releases[0]["url"]
                filename = url.split("/")[-1]
                filepath = os.path.join(PLUGIN_DIR, filename)
                
                # Create plugins directory if needed
                os.makedirs(PLUGIN_DIR, exist_ok=True)
                
                # Download file
                with urllib.request.urlopen(url, timeout=30) as response:
                    data = response.read()
                    with open(filepath, 'wb') as f:
                        f.write(data)
                
                plugin_name = plugin['name']
                self.root.after(0, lambda: self.on_install_complete(plugin, filepath))
                
            except Exception as e:
                error_msg = str(e)
                plugin_name = plugin['name']
                self.root.after(0, lambda: messagebox.showerror(
                    "Installation Failed", f"Failed to install {plugin_name}:\n{error_msg}"))
                self.root.after(0, lambda: self.status_var.set("Installation failed"))
                api.log(f"Installation failed: {e}", api.ERROR)
        
        threading.Thread(target=download, daemon=True).start()
    
    def on_install_complete(self, plugin, filepath):
        """Handle successful installation"""
        self.scan_installed_plugins()
        self.populate_list()
        
        messagebox.showinfo("Success", f"{plugin['name']} installed successfully!\n\nFile: {filepath}")
        self.status_var.set(f"Installed {plugin['name']}")
        api.log(f"Installed {plugin['name']}", api.INFO)
        
        # Refresh the details view
        self.show_plugin_details(plugin)
        self.update_action_buttons(plugin)
    
    def uninstall_selected(self):
        """Uninstall the selected plugin"""
        plugin = self.get_selected_plugin()
        if not plugin:
            return
        
        if not messagebox.askyesno("Confirm Uninstall", 
                                   f"Are you sure you want to uninstall {plugin['name']}?"):
            return
        
        try:
            # Find and delete the plugin file
            plugin_id = plugin.get("id", "")
            plugin_type = plugin.get("type", "")
            
            extensions = {
                "DLL": ".dll",
                "Python": ".py",
                "SO": ".so"
            }
            
            ext = extensions.get(plugin_type, "")
            filepath = os.path.join(PLUGIN_DIR, f"{plugin_id}{ext}")
            
            if os.path.exists(filepath):
                os.remove(filepath)
                self.scan_installed_plugins()
                self.populate_list()
                
                messagebox.showinfo("Success", f"{plugin['name']} uninstalled successfully!")
                self.status_var.set(f"Uninstalled {plugin['name']}")
                api.log(f"Uninstalled {plugin['name']}", api.INFO)
                
                # Refresh the details view
                self.show_plugin_details(plugin)
                self.update_action_buttons(plugin)
            else:
                messagebox.showerror("Error", f"Plugin file not found: {filepath}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to uninstall:\n{str(e)}")
            api.log(f"Uninstall failed: {e}", api.ERROR)
    
    def load_selected(self):
        """Load the selected plugin into runtime"""
        plugin = self.get_selected_plugin()
        if not plugin:
            return
        
        plugin_id = plugin.get("id", "")
        plugin_type = plugin.get("type", "")
        
        extensions = {
            "DLL": ".dll",
            "Python": ".py",
            "SO": ".so"
        }
        
        ext = extensions.get(plugin_type, "")
        filename = f"{plugin_id}{ext}"
        
        try:
            # Use the host's load_plugin function
            if api.load_plugin(filename):
                messagebox.showinfo("Success", f"{plugin['name']} loaded successfully!")
                self.status_var.set(f"Loaded {plugin['name']}")
                api.log(f"Loaded plugin: {plugin['name']}", api.INFO)
                self.loaded_plugins.add(plugin_id)
            else:
                messagebox.showerror("Error", f"Failed to load {plugin['name']}")
                api.log(f"Failed to load plugin: {plugin['name']}", api.ERROR)
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load plugin:\n{str(e)}")
            api.log(f"Load error: {e}", api.ERROR)
    
    def on_closing(self):
        """Handle window close"""
        api.log("Plugin Manager GUI closed", api.INFO)
        self.root.destroy()
    
    def run(self):
        """Start the GUI main loop"""
        try:
            self.root.mainloop()
        except Exception as e:
            api.log(f"GUI mainloop error: {e}", api.ERROR)
            traceback.print_exc()


# Global instance
gui_instance = None
gui_thread = None

def start_gui():
    """Start the GUI in the main thread context"""
    global gui_instance
    try:
        gui_instance = PluginManagerGUI()
        gui_instance.run()
    except Exception as e:
        api.log(f"Failed to start GUI: {e}", api.ERROR)
        api.log(traceback.format_exc(), api.ERROR)

@api.on("showPluginManager")
def show_manager(event, payload):
    """Show the plugin manager GUI"""
    global gui_instance, gui_thread
    
    if not TKINTER_AVAILABLE:
        api.log("Cannot show Plugin Manager - Tkinter not available", api.ERROR)
        return
    
    if gui_instance is None or not gui_thread or not gui_thread.is_alive():
        api.log("Starting Plugin Manager GUI...", api.INFO)
        gui_thread = threading.Thread(target=start_gui, daemon=False)
        gui_thread.start()
    else:
        api.log("Plugin Manager already running", api.WARN)
        # Try to bring window to front
        try:
            gui_instance.root.lift()
        except:
            pass

# Auto-start on load
try:
    if TKINTER_AVAILABLE:
        api.log("Auto-starting Plugin Manager GUI...", api.INFO)
        gui_thread = threading.Thread(target=start_gui, daemon=False)
        gui_thread.start()
        api.log("Plugin Manager GUI started successfully. It will enable on ESC", api.INFO)
    else:
        api.log("Tkinter not available - Plugin Manager GUI disabled", api.WARN)
except Exception as e:
    api.log(f"Failed to auto-start Plugin Manager: {e}", api.ERROR)
    api.log(traceback.format_exc(), api.ERROR)